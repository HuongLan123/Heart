<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Vũ trụ trái tim - MINH IT</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: black;
    overflow: hidden;
    height: 100%;
  }
  canvas {
    position: absolute;
    width: 100%;
    height: 100%;
  }
  #heartCanvas {
    z-index: 0; /* vòng tròn tim ở dưới */
  }
  #pinkboard {
    z-index: 1; /* trái tim lớn ở trên */
    pointer-events: none; /* không chặn chuột */
  }
</style>
</head>
<body>

<canvas id="heartCanvas"></canvas>
<canvas id="pinkboard"></canvas>

<script>
/* ==============================
   PHẦN 1: VÒNG TRÒN TRÁI TIM
============================== */
const canvasR = document.getElementById("heartCanvas");
const ctxR = canvasR.getContext("2d");
let w, h;

function resizeR() {
  w = canvasR.width = window.innerWidth;
  h = canvasR.height = window.innerHeight;
}
window.addEventListener("resize", resizeR);
resizeR();

const tiltAngle = 40 * Math.PI / 180;
const ringCount = 3;
const ringTexts = ["Chúc cô Thùy Trung thu vui vẻ", "Trung thu ấm áp", "Trung thu nhiều xiền"];
const rings = [];

// --- KHỞI TẠO CÁC VÒNG TIM ---
for (let r = 0; r < ringCount; r++) {
  const ring = {
    hearts: [],
    text: ringTexts[r],
    currentRadius: 0,
    targetRadius: Math.min(w, h) * (0.16 + r * 0.1),
    growing: true,
    appearTime: r * 3000,
    started: false,
    rotation: Math.random() * Math.PI * 2
  };

  const numHearts = 200;
  const textArcFraction = 0.25;
  const startTextAngle = Math.random() * Math.PI * 2;
  const endTextAngle = startTextAngle + 2 * Math.PI * textArcFraction;

  for (let i = 0; i < numHearts; i++) {
    const angle = (i / numHearts) * 2 * Math.PI;
    if (angle < startTextAngle || angle > endTextAngle) {
      ring.hearts.push({
        angle,
        flicker: Math.random() * 2 * Math.PI
      });
    }
  }

  ring.textStart = startTextAngle;
  ring.textEnd = endTextAngle;
  rings.push(ring);
}

// --- HÀM VẼ TIM ---
function drawHeartR(x, y, size, color, alpha) {
  ctxR.save();
  ctxR.translate(x, y);
  ctxR.scale(size, size);
  ctxR.beginPath();
  ctxR.moveTo(0, -3);
  ctxR.bezierCurveTo(2, -6, 6, -2, 0, 5);
  ctxR.bezierCurveTo(-6, -2, -2, -6, 0, -3);
  ctxR.closePath();
  ctxR.globalAlpha = alpha;
  ctxR.fillStyle = color;
  ctxR.fill();
  ctxR.restore();
}

// --- VẼ CHỮ TRÊN CUNG ---
function drawTextArcR(text, radius, startAngle, endAngle, rotation) {
  ctxR.save();
  ctxR.translate(w / 2, h / 2 + 150);
  ctxR.rotate(rotation);
  ctxR.scale(1, Math.cos(tiltAngle));
  ctxR.fillStyle = "#ffccdd";
  ctxR.font = "bold 22px Arial";
  ctxR.textAlign = "center";
  ctxR.textBaseline = "middle";

  const textLength = text.length;
  const arcLength = endAngle - startAngle;
  const step = arcLength / (textLength - 1);

  for (let i = 0; i < textLength; i++) {
    const angle = startAngle + i * step;
    const x = Math.cos(angle) * radius;
    const y = Math.sin(angle) * radius;
    ctxR.save();
    ctxR.translate(x, y);
    ctxR.rotate(angle + Math.PI / 2);
    ctxR.fillText(text[i], 0, 0);
    ctxR.restore();
  }
  ctxR.restore();
}

/* ==============================
   PHẦN 2: TRÁI TIM LỚN Ở TRUNG TÂM
============================== */
const canvasH = document.getElementById("pinkboard");
const ctxH = canvasH.getContext("2d");

function resizeH() {
  canvasH.width = window.innerWidth;
  canvasH.height = window.innerHeight;
}
window.addEventListener("resize", resizeH);
resizeH();

function pointOnHeart(t) {
  return {
    x: 16 * Math.pow(Math.sin(t), 3),
    y: -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t))
  };
}

const HEART_SCALE = 15;
const PARTICLE_COUNT = 7000;
const particles = [];
const bpm = 20;
const beatPeriod = 60 / bpm;
let start = performance.now();

function randomPointInHeart() {
  let t, p;
  do {
    t = Math.random() * Math.PI * 2 - Math.PI;
    const r = Math.random();
    p = pointOnHeart(t);
    p.x *= HEART_SCALE * Math.pow(r, 1/2);
    p.y *= HEART_SCALE * Math.pow(r, 1/2);
  } while (Math.abs(p.x) < 1 && Math.abs(p.y) < 1);
  return p;
}

for (let i = 0; i < PARTICLE_COUNT; i++) {
  const p = randomPointInHeart();
  p.angle = Math.atan2(p.y, p.x) + (Math.random() - 0.5) * 0.5;
  particles.push(p);
}

/* ==============================
   PHẦN 3: KẾT HỢP ANIMATION
============================== */
function render(time) {
  // --- Vẽ vòng tim ---
  ctxR.clearRect(0, 0, w, h);
  const currentTime = time || 0;
  for (let r = 0; r < rings.length; r++) {
    const ring = rings[r];
    if (currentTime >= ring.appearTime) ring.started = true;
    if (!ring.started) continue;

    if (ring.growing) {
      ring.currentRadius += 0.6;
      if (ring.currentRadius >= ring.targetRadius) ring.growing = false;
    }

    ring.rotation += 0.0012 + r * 0.0005;
    ctxR.save();
    ctxR.translate(w / 2, h / 2 + 150);
    ctxR.scale(1, Math.cos(tiltAngle));
    for (const p of ring.hearts) {
      const angle = p.angle + ring.rotation;
      const x = Math.cos(angle) * ring.currentRadius;
      const y = Math.sin(angle) * ring.currentRadius;
      const twinkle = 0.7 + 0.3 * Math.sin(Date.now() * 0.004 + p.flicker);
      drawHeartR(x, y, 1.2, "#ff99cc", twinkle);
    }
    ctxR.restore();
    drawTextArcR(
      ring.text,
      ring.currentRadius,
      ring.textStart + ring.rotation,
      ring.textEnd + ring.rotation,
      0
    );
  }

  // --- Vẽ trái tim lớn ---
  const t = time / 1000;
  const beatPos = ((t - start / 1000) % beatPeriod) / beatPeriod;
  const pulse = 0.5 + 0.5 * Math.sin(beatPos * 2 * Math.PI);
  ctxH.clearRect(0, 0, canvasH.width, canvasH.height);
  const hue = 330 + Math.sin(t * 3) * 15;
  const color = `hsl(${hue}, 100%, ${45 + pulse * 25}%)`;

  ctxH.save();
  ctxH.translate(canvasH.width / 2, canvasH.height / 2 - 150);
  const scale = 1 + pulse * 0.04;
  ctxH.scale(scale, scale);
  ctxH.shadowColor = color;
  ctxH.shadowBlur = 10 + pulse * 10;
  ctxH.lineWidth = 1 + pulse * 0.7;
  ctxH.strokeStyle = color;
  ctxH.beginPath();

  for (let i = 0; i < particles.length; i++) {
    const p = particles[i];
    const baseLen = 2.0;
    const stretch = 6.0;
    const len = baseLen + stretch * pulse;
    const dx = Math.cos(p.angle) * len;
    const dy = Math.sin(p.angle) * len;
    ctxH.moveTo(p.x - dx / 2, p.y - dy / 2);
    ctxH.lineTo(p.x + dx / 2, p.y + dy / 2);
  }
  ctxH.stroke();
  ctxH.restore();

  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>
